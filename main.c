/*
JTKJ Harjoitustyö 2020

Joona Meriläinen
*/

/* C libraries */
#include <stdio.h>
#include <string.h>

/* XDCtools files */
#include <xdc/std.h>
#include <xdc/runtime/System.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Clock.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/drivers/PIN.h>
#include <ti/drivers/pin/PINCC26XX.h>
#include <ti/drivers/i2c/I2CCC26XX.h>
#include <ti/drivers/I2C.h>
#include <ti/drivers/Power.h>
#include <ti/drivers/power/PowerCC26XX.h>
#include <ti/mw/display/Display.h>
#include <ti/mw/display/DisplayExt.h>
#include <ti/drivers/UART.h>

/* Board Header files */
#include "Board.h"

#include "wireless/comm_lib.h"
#include "sensors/opt3001.h"
#include "sensors/mpu9250.h"

/* Tasks */
#define STACKSIZE 2048
Char sensorTaskStack[STACKSIZE];
Char displayTaskStack[STACKSIZE];
Char commTaskStack[STACKSIZE];

char moveMsg[24] = ""; // Wireless message to send
char recMsg[80] = "";  // Received wireless message

char winText[16] = ""; // Game condition notification message
int turnCount = 0;     // In-game turn count

int clearReq = 0;

// States
enum state { MENU = 0, GAME, GAME_OVER };
enum state myState = MENU;

// Directions
enum dir { UP = 0, RIGHT, DOWN, LEFT };

// RTOS variables for first button pin
static PIN_Handle buttonHandle;
static PIN_State buttonState;

// RTOS variables for second button pin
static PIN_Handle button1Handle;
static PIN_State button1State;

// Config for first button pin
PIN_Config buttonConfig[] = {
   Board_BUTTON0  | PIN_INPUT_EN | PIN_PULLUP | PIN_IRQ_NEGEDGE, // Neljän vakion TAI-operaatio 
   PIN_TERMINATE // Taulukko lopetetaan aina tällä vakiolla
};

// Config for second button pin
PIN_Config button1Config[] = {
   Board_BUTTON1  | PIN_INPUT_EN | PIN_PULLUP | PIN_IRQ_NEGEDGE, // Neljän vakion TAI-operaatio 
   PIN_TERMINATE // Taulukko lopetetaan aina tällä vakiolla
};

// MPU global variables
static PIN_Handle hMpuPin;
static PIN_State MpuPinState;
static PIN_Config MpuPinConfig[] = {
    Board_MPU_POWER  | PIN_GPIO_OUTPUT_EN | PIN_GPIO_HIGH | PIN_PUSHPULL | PIN_DRVSTR_MAX,
    PIN_TERMINATE
};

// MPU I2C interface
static const I2CCC26XX_I2CPinCfg i2cMPUCfg = {
    .pinSDA = Board_I2C0_SDA1,
    .pinSCL = Board_I2C0_SCL1
};

// Pixel data for title screen
const uint8_t titleScreen [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x30, 0x00,
0x60, 0xE0, 0xFF, 0xFC, 0x0E, 0x00, 0xFF, 0x80, 0x00, 0x7C, 0x18, 0x00, 0xC1, 0xF0, 0xFF, 0xFC,
0x1F, 0x00, 0xFF, 0xE0, 0x00, 0x6C, 0x18, 0x00, 0xC1, 0xB0, 0x03, 0x00, 0x1B, 0x00, 0xC0, 0xE0,
0x00, 0x6C, 0x1C, 0x01, 0xC1, 0xB0, 0x03, 0x00, 0x1B, 0x00, 0xC0, 0x70, 0x00, 0xC6, 0x0C, 0x01,
0x83, 0x18, 0x03, 0x00, 0x31, 0x80, 0xC0, 0x30, 0x00, 0xC6, 0x0C, 0x01, 0x83, 0x18, 0x03, 0x00,
0x31, 0x80, 0xC0, 0x30, 0x00, 0xC6, 0x06, 0x03, 0x03, 0x18, 0x03, 0x00, 0x31, 0x80, 0xC0, 0x30,
0x01, 0x83, 0x06, 0x03, 0x06, 0x0C, 0x03, 0x00, 0x60, 0xC0, 0xC0, 0x70, 0x01, 0x83, 0x07, 0x07,
0x06, 0x0C, 0x03, 0x00, 0x60, 0xC0, 0xC0, 0xE0, 0x03, 0x81, 0x83, 0x06, 0x0E, 0x06, 0x03, 0x00,
0xE0, 0x60, 0xFF, 0xE0, 0x03, 0x01, 0x83, 0x06, 0x0C, 0x06, 0x03, 0x00, 0xC0, 0x60, 0xFF, 0xC0,
0x03, 0xFF, 0x81, 0x8C, 0x0F, 0xFE, 0x03, 0x00, 0xFF, 0xE0, 0xC0, 0xE0, 0x07, 0xFF, 0xC1, 0x8C,
0x1F, 0xFF, 0x03, 0x01, 0xFF, 0xF0, 0xC0, 0x60, 0x06, 0x00, 0xC1, 0x8C, 0x18, 0x03, 0x03, 0x01,
0x80, 0x30, 0xC0, 0x30, 0x0E, 0x00, 0xE0, 0xD8, 0x38, 0x03, 0x83, 0x03, 0x80, 0x38, 0xC0, 0x30,
0x0C, 0x00, 0x60, 0xD8, 0x30, 0x01, 0x83, 0x03, 0x00, 0x18, 0xC0, 0x18, 0x0C, 0x00, 0x60, 0xF8,
0x30, 0x01, 0x83, 0x03, 0x00, 0x18, 0xC0, 0x18, 0x18, 0x00, 0x30, 0x70, 0x60, 0x00, 0xC3, 0x06,
0x00, 0x0C, 0xC0, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x20, 0x02, 0x20, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
0x02, 0x20, 0x00, 0x00, 0x01, 0x13, 0x9C, 0xF7, 0x83, 0x9E, 0x44, 0x3C, 0x8F, 0xF9, 0xCF, 0x00,
0x01, 0xE2, 0x22, 0x84, 0x00, 0x51, 0x44, 0x22, 0x8A, 0x22, 0x28, 0x80, 0x01, 0x02, 0x3E, 0x73,
0x83, 0xD1, 0x28, 0x22, 0x8A, 0x22, 0x28, 0x80, 0x01, 0x02, 0x20, 0x10, 0x84, 0x51, 0x28, 0x22,
0x8A, 0x22, 0x28, 0x80, 0x01, 0x02, 0x1E, 0xF7, 0x87, 0xD1, 0x10, 0x3C, 0x7B, 0xB9, 0xC8, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xE7, 0x07, 0x93, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x88, 0x84, 0x50, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x84, 0x53, 0xCA,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x84, 0x54, 0x4A, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xE7, 0x07, 0x97, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x18,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Black and white palette
uint32_t imgPalette[] = {0, 0xFFFFFF};

// Title screen image
const tImage image = {
    .BPP = IMAGE_FMT_1BPP_UNCOMP,
    .NumColors = 2,
    .XSize = 12*8-1,
    .YSize = 96,
    .pPalette = imgPalette,
    .pPixel = titleScreen
};

void startGame() {
    myState = GAME;
    turnCount = 0; 
    clearReq = 1;
}

// Button 0 interrupt function
void buttonFxn(PIN_Handle handle, PIN_Id pinId) {
    if (myState == MENU) {
        startGame();
    } else {
        myState = MENU;
        clearReq = 1;
    }
}

// Button 1 interrupt function
void button1Fxn(PIN_Handle handle, PIN_Id pinId) {
    if (myState == MENU) {
        startGame();
    } else {
        myState = MENU;
        clearReq = 1;
    }
}

// Wireless transfer task
Void commTaskFxn(UArg arg0, UArg arg1) {
    char payload[16]; // Buffer
    uint16_t senderAddr;
    
    // Initialize
    int32_t result = StartReceive6LoWPAN();
    if(result != true) {
      System_abort("Wireless receive start failed");
    }
    
    while (1) {
        if (myState == GAME) {
            // Check if message is waiting
            if (GetRXFlag()) {
               // Clear the buufer
               memset(payload,0,16);
               
               // Message to the buffer
               Receive6LoWPAN(&senderAddr, payload, 16);
               
               // Print received message
               sprintf(recMsg, "recMsg from %d: %s\n", payload, senderAddr);
               System_printf(recMsg);
               System_flush();
               
               // Check if the received message confirmed a win or a lose
               if(strcmp(payload, "56,WIN") == 0) {
                   sprintf(winText, "YOU WON!");
                   myState = GAME_OVER;
               } else if(strcmp(payload, "56,LOST GAME") == 0) {
                   sprintf(winText, "YOU LOST!");
                   myState = GAME_OVER;
               }
            }
        }
    }
}

// Display Task
Void displayTaskFxn(UArg arg0, UArg arg1) {
    // Initialize
    Display_Params params;
    Display_Params_init(&params);
    params.lineClearMode = DISPLAY_CLEAR_BOTH;
    
    Display_Handle displayHandle = Display_open(Display_Type_LCD, &params);
    
    tContext *pContext = DisplayExt_getGrlibContext(displayHandle);
    
    // Text rows
    char turnTitle[20] = "";
    char moveRow[8] = "";
    
    while(1) {
        // Clear the screen if requested by other task/function
        if (clearReq == 1) {
            Display_clear(displayHandle);
            clearReq = 0;
        }
        
        if (myState == GAME || myState == GAME_OVER) {
            // Print text rows
            if (displayHandle) {
                if(turnCount == 0) {
                    sprintf(turnTitle, "GAME BEGINS!");
                    sprintf(moveRow, "");
                    sprintf(winText, "");
                } else {
                    sprintf(turnTitle, "Turn #%d", turnCount);
            
                    if (strcmp(moveMsg, "event:LEFT") == 0) {
                        sprintf(moveRow, "Left");
                    } else if (strcmp(moveMsg, "event:RIGHT") == 0) {
                        sprintf(moveRow, "Right");
                    } else if (strcmp(moveMsg, "event:UP") == 0) {
                        sprintf(moveRow, "Up");
                    } else if (strcmp(moveMsg, "event:DOWN") == 0) {
                        sprintf(moveRow, "Down");
                    }
                }
            }   
            
            Display_print0(displayHandle, 1, 1, turnTitle);
            Display_print0(displayHandle, 3, 1, moveRow);
            Display_print0(displayHandle, 6, 1, winText);
            
        } else if(myState == MENU) {
            if (pContext) {
                GrImageDraw(pContext, &image, 0, 0);
                GrFlush(pContext);
            }
        }
        
        Task_sleep(500000/Clock_tickPeriod);
    }
}

// Sensor task
Void sensorTaskFxn(UArg arg0, UArg arg1) {
    float ax, ay, az, gx, gy, gz; // Accelerometer and gyro data
	double pressure, temperature; // Pressure and temperature sensor data

    // Initialize
	I2C_Handle i2cMPU;
	I2C_Params i2cMPUParams;
    I2C_Params_init(&i2cMPUParams);
    i2cMPUParams.bitRate = I2C_400kHz;
    i2cMPUParams.custom = (uintptr_t)&i2cMPUCfg;

    // MPU open I2C
    i2cMPU = I2C_open(Board_I2C, &i2cMPUParams);
    if (i2cMPU == NULL) {
        System_abort("Error Initializing I2CMPU\n");
    }

    // MPU power on
    PIN_setOutputValue(hMpuPin, Board_MPU_POWER, Board_MPU_POWER_ON);

    // Wait for the sensor to power up
	Task_sleep(100000 / Clock_tickPeriod);
	
    // MPU9250 setup
	mpu9250_setup(&i2cMPU);
    
    // MPU close I2C
    I2C_close(i2cMPU);

	while (1) {
        // MPU open I2C
	    i2cMPU = I2C_open(Board_I2C, &i2cMPUParams);
	    if (i2cMPU == NULL) {
	        System_abort("Error Initializing I2CMPU\n");
	    }

	    // MPU ask data
		mpu9250_get_data(&i2cMPU, &ax, &ay, &az, &gx, &gy, &gz);
		
		if (gy > 100 && gx < 50 && gx > -50 && myState == GAME) {              // Right tilt input
		    sprintf(moveMsg, "event:RIGHT");
		    turnCount++;
            I2C_close(i2cMPU);
            Send6LoWPAN(IEEE_SERVER_ADDR, moveMsg, strlen(moveMsg));
            StartReceive6LoWPAN();
            Task_sleep(1000000 / Clock_tickPeriod);
    	} else if (gy < -100 && gx < 50 && gx > -50 && myState == GAME) {      // Left tilt input
    	    sprintf(moveMsg, "event:LEFT");
		    turnCount++;
    		I2C_close(i2cMPU);
    		Send6LoWPAN(IEEE_SERVER_ADDR, moveMsg, strlen(moveMsg));
    		StartReceive6LoWPAN();
    		Task_sleep(1000000 / Clock_tickPeriod);
    	} else if (gx > 100 && gy < 50 && gy > -50 && myState == GAME) {       // Up tilt input
    	    sprintf(moveMsg, "event:UP");
		    turnCount++;
            I2C_close(i2cMPU);
            Send6LoWPAN(IEEE_SERVER_ADDR, moveMsg, strlen(moveMsg));
            StartReceive6LoWPAN();
            Task_sleep(1000000 / Clock_tickPeriod);
    	} else if (gx < -100 && gy < 50 && gy > -50 && myState == GAME) {      // Down tilt input
    	    sprintf(moveMsg, "event:DOWN");
		    turnCount++;
    		I2C_close(i2cMPU);
    		Send6LoWPAN(IEEE_SERVER_ADDR, moveMsg, strlen(moveMsg));
    		StartReceive6LoWPAN();
    		Task_sleep(1000000 / Clock_tickPeriod);
    	} else {                                            // No input found
            I2C_close(i2cMPU);
            Task_sleep(50000 / Clock_tickPeriod);
    	}
	}

	// MPU9250 power off
	// Because of loop forever, code never goes here
    PIN_setOutputValue(hMpuPin,Board_MPU_POWER, Board_MPU_POWER_OFF);
}

Int main(void) {
	// Initialize board
    Board_initGeneral();
    Board_initI2C();
    
    // Open MPU power pin
    hMpuPin = PIN_open(&MpuPinState, MpuPinConfig);
    if (hMpuPin == NULL) {
    	System_abort("Pin open failed!");
    }
    
    // Sensor task variables
	Task_Handle sensorTask;
	Task_Params sensorTaskParams;

    // Sensor task
    Task_Params_init(&sensorTaskParams);
    sensorTaskParams.stackSize = STACKSIZE;
    sensorTaskParams.stack = &sensorTaskStack;
    sensorTaskParams.priority=2;

    sensorTask = Task_create(sensorTaskFxn, &sensorTaskParams, NULL);
    if (sensorTask == NULL) {
    	System_abort("Task create failed!");
    }
    
    // Display task variables
	Task_Handle displayTask;
	Task_Params displayTaskParams;
    
    // Display task
    Task_Params_init(&displayTaskParams);
    displayTaskParams.stackSize = STACKSIZE;
    displayTaskParams.stack = &displayTaskStack;
    displayTaskParams.priority=2;

    displayTask = Task_create(displayTaskFxn, &displayTaskParams, NULL);
    if (displayTask == NULL) {
    	System_abort("Task create failed!");
    }
    
    // Comm task variables
	Task_Handle commTask;
	Task_Params commTaskParams;
    
    // Comm task
    Task_Params_init(&commTaskParams);
    commTaskParams.stackSize = STACKSIZE;
    commTaskParams.stack = &commTaskStack;
    commTaskParams.priority=1;

    sensorTask = Task_create(commTaskFxn, &commTaskParams, NULL);
    if (commTask == NULL) {
    	System_abort("Task create failed!");
    }
    
    // Button pin
    buttonHandle = PIN_open(&buttonState, buttonConfig);
    if(!buttonHandle) {
    System_abort("Error initializing button pins\n");
    }
    
    // Interrupt for button pin
    if (PIN_registerIntCb(buttonHandle, &buttonFxn) != 0) {
      System_abort("Error registering button callback function");
    }
    
    // Button pin
    button1Handle = PIN_open(&button1State, button1Config);
    if(!buttonHandle) {
    System_abort("Error initializing button pins\n");
    }
    
    // Interrupt for button pin
    if (PIN_registerIntCb(button1Handle, &button1Fxn) != 0) {
      System_abort("Error registering button callback function");
    }
    
    // Initialize wireless transfer
    Init6LoWPAN();

    // Start BIOS
    BIOS_start();

    return (0);
}
